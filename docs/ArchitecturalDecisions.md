# JSON documentation

This document contains all architectural decisions that have been decided upon that best fit the projects needs. 

# Table skeleton

Below displays how decisions have been organized inside a table for better clarity.

| Name                    | Description                                                                    |
|-------------------------|--------------------------------------------------------------------------------|
| Issue                   | Title relating to what a decision had to be made about                         |
| Date                    | Date on which the decision was made                                            |
| Decision                | The outcome of the decision                                                    |
| Alternatives considered | Other alternatives that were considered, i.e., that which was not the decision |
| Argument (brief)        | Short reasoning behind the made decision                                       |

# Compatibility with existing renderers

| Name                    | Description                                                                                                                                                                                                                                                                                                         |
|-------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Issue                   | When to change the JSON format                                                                                                                                                                                                                                                                                      |
| Date                    | 07/12/2023                                                                                                                                                                                                                                                                                                          |
| Decision                | We stick to the existing Living Documentation JSON format. Specifically, we do not break existing renderers. Where we cannot fit information into the existing structure, and we are certain it is relevant, we extend the structure in such a way that existing renderers (also those written in C#) keep working. |
| Alternatives considered | Initially, we also considered whether the format should be entirely redesigned to better fit the new situation, for example changing object keys to have non-C#-specific, non-Java-specific names.                                                                                                                  |
| Argument                | Since we do not have access to the implementations of existing renderers and (therefore) cannot update them to match, it would be bad form for us to impose breaking changes and break working code.<br /> Existing choices on what to include in the JSON file can show what information has been needed so far.   |


# Parser

| Name                    | Description                                                                                                                                                                                                                                                                                                                                |
|-------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Issue                   | What Java parser to use                                                                                                                                                                                                                                                                                                                    |
| Date                    | 28/09/2023                                                                                                                                                                                                                                                                                                                                 |
| Decision                | JavaParser                                                                                                                                                                                                                                                                                                                                 |
| Alternatives considered | Tree-sitter                                                                                                                                                                                                                                                                                                                                |
| Argument                | JavaParser was chosen over Tree-sitter for its ability to do type resolving, that is, extracting the qualified names of objects and having built- in methods for traversing the Syntax Tree compared to Tree-sitter where extracting  the qualified names and traversing the Syntax Tree would require manual implementation of the logic. |

# Modifier mapping

| Name                    | Description                                                                                                                                                                                                                                                                                                                       |
|-------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Issue                   | How to map Java’s modifiers (public, private, final…) to Living Documentation/C# modifiers (public, private, sealed…)                                                                                                                                                                                                             |
| Date                    | 10/10/2023                                                                                                                                                                                                                                                                                                                        |
| Decision                | Wherever there is a semantically equivalent modifier in both languages, it is translated. Java public becomes C# public; Java final becomes C# sealed or C# readonly, depending on usage.<br /> Java-specific modifiers that have no C# equivalent are ignored.                                                                   |
| Alternatives considered | An alternative would have been to change the set of Living Documentation modifiers to add new Java-specific values, for all modifiers or only for ones that have no C# equivalent.                                                                                                                                                |
| Argument                | Changing the set of Living Documentation modifiers would mean that existing renderer code, including renderers, would not be able to understand the JSON that we output, which would break our compatibility goals.<br /> The Java-specific modifiers with no C# equivalent were judged to be of unlikely architectural relevance |

# The mapping of Java annotation interfaces (or AnnotationDeclaration)

| Name                    | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
|-------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Issue                   | How to map the Java annotation interface types to the Living Documentation JSON structure.                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| Date                    | 12/01/2024                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| Decision                | Map @interface as interface type (type 1).                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| Alternatives considered | Create a separate type (besides class, interface, enum, etc.) for annotation interfaces.                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| Argument                | The annotation interface seems too specific to create a custom type. Especially considering custom attributes in C# are defined using normal classes (extending the Attribute base class). Furthermore, the @interface and interface keywords are highly similar, so likely not to create too much confusion for the developers working with the Living Documentation tool. <br/> Finally, @interface and interface can be distinguished from the JSON by the @Retention and @Target attributes/annotations normally accompanying the annotation declaration. |


| Name                    | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
|-------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Issue                   | How to map the Java annotation interface member values (AnnotationMemberDeclaration) to the Living Documentation JSON structure.                                                                                                                                                                                                                                                                                                                                                              |
| Date                    | 13/01/2024                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| Decision                | AnnotationMemberDeclarations are mapped to Fields; where the default value is mapped to Initializer.                                                                                                                                                                                                                                                                                                                                                                                          |
| Alternatives considered | Instead of mapping to a Field, map to another type member; such as to the C# property (which has no real equivalent in Java), or; to a Method.                                                                                                                                                                                                                                                                                                                                                |
| Argument                | Although AnnotationMembers are parenthesised, they may not contain parameters. Furthermore, AnnotationMembers may have default values. These can be mapped to Initializers (initial values, which is semantically quite correct) that are present in both Fields & Properties according to the JSON schema. Although Properties are not used in the Java Living Documentation implementation, Properties seem like something semantically different. Hence, the decision for Fields was made. |
